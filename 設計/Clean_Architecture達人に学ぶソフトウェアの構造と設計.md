https://www.amazon.co.jp/dp/B07FSBHS2V/

- ソフトウェアアーキテクチャの目的はシステムの構築、保守に必要な人材を最小限に抑えること
  - エンジニアの人数の増加と生産性は比例しない
    - 生産性は対数関数的な増加傾向
    - コード一行あたりのコストは指数関数的に増加
      - ここ刺さった

- アイゼンハワーのマトリックス
  - 緊急と重要は違う。重要なことが緊急になるわけではない
  - 「緊急だが重要ではない」を「緊急かつ重要」に勘違いしがち
    - 機能の緊急性より、アーキテクチャの重要性を主張することが求められる

- 構造化プログラミングではプログラムを証明可能な単位に分割し、正しいことを示す
  - 科学の理論や法則は、正しいと証明することができない
    - 証明可能ではなく、反証可能
      - 多くの労力をかけても真でないことが証明できなければ、十分に真としてみなせる
  - ソフトウェア開発は科学のような試み
    - 反証(テスト)をして真でないことが証明できなければ、そのプログラムは真とみなせる
    - 反証(テスト)可能な単位に分割しておく必要がある

- ソフトウェアアーキテクトにとってのオブジェクト指向プログラミングの利点は、ポリモーフィズムを使用することでソースコードの依存関係を絶対的に制御する能力
  - OOPがポリモーフィズムを便利にしてくれた

- 関数型プログラミングは、代入に規律を課すもの
  - 可変性の分離
    - 可変コンポーネントと不変コンポーネントがあり、不変コンポーネントは一つ以上の可変コンポーネントと通信する
      - 不変コンポーネントにできるだけ多くの処理を押し込み、可変コンポーネントの処理は最小限に保つ

- SOLID原則の目的は、以下のような性質を持つ中間レベル(モジュール)のソフトウェア構造を作ること
  - 変更に強いこと
  - 理解しやすいこと
  - コンポーネントの基盤として、多くのソフトウェアシステムで利用できること

- 単一責任の原則(SRP)
  - モジュールを変更する理由はたった一つになるべき
    - 一つのモジュールは一つのアクターに対して責務を負うべき
      - アクターの異なるコードは分割すべき
  - 「どのモジュールもたった一つのことだけを行うべき」という意味ではない
  - [こちら](https://xn--97-273ae6a4irb6e2hsoiozc2g4b8082p.com/%E3%82%A8%E3%83%83%E3%82%BB%E3%82%A4/%E5%8D%98%E4%B8%80%E8%B2%AC%E4%BB%BB%E5%8E%9F%E5%89%87/)も参考になる

- オープン・クローズドの原則(OCP)
  - 変更に対しては閉じて、拡張に対してはオープンであるべき

- リスコフの置換原則(LSP)
  - サブクラスと基底クラスを入れ替えても問題なく動くようにする
  - 継承の使い方の指針ではなく、インターフェースと実装に関するソフトウェア設計の原則

- インターフェース分離の法則(ISP)

- 依存性逆転の法則(DIP)
  - 依存位したくないのは、システム内の変化しやすい具象モジュール

- コンポーネント
  - デプロイの単位

- 再利用・リリース等価の原則(REP)
  - 再利用の単位とリリースの単位は等価になる

- 閉鎖性共通の原則（CCP）
  - 同じ理由、同じタイミングで変更されるクラスをコンポーネントにまとめること
    - 変更の理由やタイミングが異なるクラスは、別のコンポーネントに分けること

- 全再利用の原則（CRP）
  - コンポーネントのユーザーに対して、実際には使わないものへの依存を強要してはいけない
    - 一つのクラスだけを再利用することは滅多にないので、一緒に再利用する複数のクラスは同じコンポーネントにまとめるべき
      - 密結合していないクラスは、同じコンポーネントに含めるべきではない

> 再利用・リリース等価の原則（REP）と閉鎖性共通の原則（CCP）は、包含関係にある。どちらも、ひとつのコンポーネントを大きくする方向に働くものだ。一方の全再利用の原則（CRP）は、これらとは相反する原則で、ひとつのコンポーネントを小さくする方向に働くものだ。これら3つの原則のバランスをうまくとるのがソフトウェアアーキテクトの腕の見せ所だ

- コンポーネントはボトムアップで設計する
  - トップダウンで設計するのは不可能
    - 都度変更していく

- コンポーネントに関する原則
  - 安定依存の原則（SDP）
    - 安定度の高い方向に依存すること。
      - 複数のコンポーネントから依存されている→安定度高い
      - 全てのコンポーネントの安定度を高くしておく必要はない

  - 安定度・抽象度等価の原則（SAP）
    - コンポーネントの抽象度は、その安定度と同程度でなければいけない。
  - 安定依存の原則と安定度・抽象度等価の還俗の組み合わせは、コンポーネント版の依存関係逆転の法則といえる
    - コンポーネントも具体→抽象に依存するように設計すべきという話

> インターフェイスはモデルにとって重要ではない。そして、モデルはビジネスルールである

忘れがちなので、常に意識しておきたい

- 方針とレベル
  - 方針: 入力を出力に変換するプログラム(単なるプログラムのイメージ)
  - レベル: 入力と出力から離れているほど、レベルが高い(変更されづらい)と考える
    - ビジネスルールはシステムの入出力とは最も切り離されているべきなので、レベルが高いと考える
    - ユースケースはアプリケーション固有の処理を記述するところなので、ビジネスルールと比べるとレベルが低い(システムの入出力と近い)と考えられる

- 最重要ビジネスルール
  - そのビジネスがお金を生み出すルール。システムが自動化されていなくても、手動の手続きで表現できる
- 最重要ビジネスデータ
  - 最重要ビジネスルールが必要とするデータ
- エンティティ
  - 最重要ビジネスルール、最重要ビジネスデータを持つオブジェクト
  - アプリケーション固有のロジックを含まないことが望ましい
    - アプリケーションとは切り離す
    - ビジネスルールはアプリケーションの中で最も独立して、最も再利用可能なコードでなければならない

- ユースケース
  - 自動化されたシステムならではのルールを記述する場所
  - エンティティのダンスを記述する
  - 入出力の方法に依存しない
    - HTTPリクエストやDBのことは知らなくて済むように設計する

- Humble Objectパターン
  - テストしやすい部分とテストしにくい部分(Humble Object)に分けて考える
  - Humble Objectになるもの
    - GUI, DB周り、外部APIなど
