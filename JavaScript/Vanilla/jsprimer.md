# jsprimerで学んだことについてメモ

- https://jsprimer.net

- jsの共通部分はECMAScriptという
- jsは大部分がオブジェクトで、オブジェクト同士のコミュニケーションだと意識すると良い
- 文末はセミコロンで区切られる。セミコロンを書かなくてもよい場合もあるが、意図しない挙動の原因となりやすいので基本的に書くようにする

## const, let, var
- varの問題点を解消するためにconstとletが生まれた

- const
  - 初期値必須
  - 再代入不可
    - オブジェクトなどを定義し、その中身を変更することは可能
  - 値を再代入するような変数でない場合、constを用いる
- let
  - 初期値は必須でない
    - `let foo; // => undefind`
  - 再代入可
  - 同じ名前の変数を再定義できない
- var
  - ほぼletと同じだが、同じ名前の変数を再定義できてしまうため、問題が起こりやすい
    - const: 一つの変数へ値を再代入できないようにする
    - let: 同じ名前の変数を再定義できないようにする
  - varを使う場合、ほぼほぼletとconstで置き換えられる
  - varが残っているのは後方互換性のため

## 型

- プリミティブ型
  - 真偽値、文字列、数値など。イミュータブル
- オブジェクト
  - プリミティブまたはオブジェクトの集合。ミュータブル
### リテラル
- 型の宣言を簡単に扱えるようにしたもの
  - '文字列'の''はstring型のリテラル

## ラッパーオブジェクト
- プリミティブ型をobject型にする（ラップする）。
  - `const str = new String('hoge'); // typeof str => object`
- あんまり使わないかも？

## 演算子
- オペランド: 演算される対象。1+2における、1と2のこと

### 等価演算子
- ===と==の違い
  - ==は暗黙的な型変換される（1 == '1' => true, 1 === '1' => false)

### 制御文

- 三項演算子は代入と評価が同時に行えるが、if文は分けなければいけない
- swith文では、必ずcaseとbreakをセットにする

## 関数

- メソッド: Rubyでは関数のことだが、JSではオブジェクトのプロパティとして使われている関数をメソッドという
  - `{key: function() {} }`
  - オブジェクトの省略記法もある
- 仮引数: 関数を定義するときに仮に作成する引数のこと
- 可変長引数の受け取り方
  - rest parametersを使う
  - argumentsを使う（非推奨）
- 関数宣言は文、関数式は値
  - アロー関数が推奨される
- コールバック関数: 引数として渡される関数
- 高階関数: コールバック関数を引数にとる関数
- ファーストクラスファンクション(第一級関数): 関数を値として扱えること。jsの関数は第一級関数
> 第1級オブジェクトというのは数値や文字列のような、変数に割り当てられたり、なんらかの計算処理ができたりといった、プログラミングの基本機能が使える対象のことを指します。JavaScriptでは変数に関数を突っ込めるので、関数は第1級オブジェクトです。


## 関数とスコープ

- ブロックスコープ: ブロックによるスコープ。ifや関数など
  - for文は1ループごとに毎回新しいスコープを作成している
- スコープチェーン: 変数を参照する場合、現在のスコープから外側のスコープという順番で参照する。二段以上ネストしている場合、中から外は参照できるが、外から中は参照できない
- グローバルスコープ: 最も外側。ブラウザ上ではwindow
  - グローバル変数: 自分でグローバルスコープに定義した変数
  - ビルトインオブジェクト: 言語や環境が元々提供しているオブジェクト。グローバルスコープに定義されているものとして扱える
  - ビルトインオブジェクトと同じ名前のグローバル変数を定義した場合、グローバル変数が優先される
- 変数の隠蔽: スコープチェーンの仕組みにより、外側の変数で定義した変数名と内側で定義した変数名が被った場合、外側が機能しなくなってしまう問題。これを避けるにはなるべく小さいスコープの中に変数を定義していくことが重要
- varの巻き上げ: varは値を代入しないで参照するとundefindになるが、代入と宣言をする行よりも前に参照でき、その値はundefindになる。まるで行頭にvarを値なしで宣言したような挙動になるため、varの巻き上げと呼ばれる。またネストしたスコープ内でもその外側で宣言したような挙動になる
- 関数宣言と巻き上げ: 関数宣言の前の行でもその関数が呼び出せるのは、関数宣言がvarのようにグローバルスコープの行頭に巻き上げられるから。これは別に問題のない挙動

- 即時実行関数（IIFE, Immediately-Invoked Function Expression）: 宣言と実行を同時に行う。グローバルスコープを汚さないために使われる。ES6からはブロックスコープ内に処理を書く形で代用

### クロージャー

- 静的スコープ: 呼び出した場所に左右されず、変数の参照先が決まっている
- 動的スコープ: 呼び出し元によって変数のスコープが動的に変わる。JSのthisは動的スコープ
- ガベージコレクション: どこからも参照されなくなったデータをメモリから開放する
- クロージャー: 静的スコープとガベージコレクションを合わせて、関数に状態を保持させることができる
  - 用途
  - 関数に状態を持たせる手段として
  - 外から参照できない変数を定義する手段として
  - グローバル変数を減らす手段として
  - 高階関数の一部部分として
  - クロージャーについても要復習

## 関数とthis

### アロー関数以外
- thisは関数呼び出し時に暗黙的に渡される引数のようなもの
- 関数、メソッドのthisの基本的な参照先はベースオブジェクト(Rubyでいうところのレシーバー)
  - thisが問題となる時
    - 上記の関数内でのthisは暗黙的な引数のようなものという性質が原因となる
    - メソッドとして定義したときに、メソッドを変数に代入するとメソッドのベースオブジェクトが変わってしまう
    - 対処法
      - そもそもメソッドとして定義した関数はメソッドとして呼ぶ（推奨）
      - apply, call, bindを使う
### アロー関数でのthis
- アロー関数定義時に静的に決定される
  - スコープチェーンの仕組みにより、外側のthisを参照する


## 式と文

- 式: 値を生成し、変数に代入できるもの
  - `1 + 1`、関数、関数式など
  - 式は文になれる
- 文: 変数に代入できないもの
  - if, for、関数宣言など
  - 文の末尾にはセミコロンをつける
  - 文は式になれない
- ブロック{}で終わる文はセミコロンを付けなくて良い
  - 関数式はブロックで終わる式なので、セミコロンつける;

## ループ処理

- 配列: forEachを使う
- オブジェクト: for in を使うと、継承元のオブジェクトまで見に行き、意図しない挙動になる可能性がある
  - `Object.keys.forEach`を使う。Object.keysで配列にしてしまい、forEachで処理する
- for of文: itterableオブジェクトに対して使える

## オブジェクト

- key: valueの組み合わせをプロパティという
- keyはシングルクオートを省略できる
  - `{key: 'value'} <=> {'key': 'value'}`
- keyとvalueの変数名が同じ場合、省略記法が使える
  - `{name: name} => {name}`
- Object(ビルトインオブジェクト)のインスタンスが`{}`(オブジェクトリテラル)
  - `let obj = new Object // => {}`という形でもかけるけど、まあ使わない
- プロパティへのアクセス
  - ドット記法: `obj.key`
  - ブラケット記法: `obj['key']`
  - keyが変数である場合、ドット記法は使えず、`obj[key]`という形で使える
- オブジェクトを凍結したい場合、Object.freeze({})を使う
- スタティックメソッド
  - Object(ビルトインオブジェクト)に用意されたメソッド。Rubyのクラスメソッドみたいな感覚？
    - Object.keys, Object.values, Object.entriesなど

## プロトタイプ

- ほとんどのオブジェクトは、Objectを継承し、Object.prototypeも継承する
- プロトタイプメソッド: Object.prototypeにほとんどのオブジェクトで使用できるメソッド（toStringなど)が格納されている

## 配列

- 配列もオブジェクトの一種
  - `typeof [] // => 'object'`
- 多次元配列: 配列がネストしてるやつ
- 破壊的、非破壊的メソッドが混在しており、わかりにくいので配列を扱う際には注意が必要
- filter: 元の配列から条件に合うものだけを返す

## 文字列

- 文字列をしっかり扱うときがきたら読み返す
- テンプレートリテラルだけでなく、タグ付き関数もある
- よくわからなかったので、要復習

### Unicode

- jsは文字コードとしてUnicode, エンコード方式としてUTF-16を採用
- CodePoint(符号位置): 一つの文字に対する一意のID

## ラッパーオブジェクト

- プリミティブ型に対応するオブジェクト
  - 例: string型
  - string型とStringオブジェクトのインスタンスは同じものではないが、どちらもstring用のメソッドが使える
    - string型が自動的にStringラッパーオブジェクトに型変換されるので、どちらも同じように使える

## クラス

- コンストラクタ: インスタンスの初期化処理を行う場所。
  - returnは書かなくて良い
  - 普通の関数とは異なる
- プロトタイプメソッド: クラスに定義した関数はプロトタイプに定義されたメソッドとなり、`クラス名.メソッド名`で呼び出せる
- スタティックメソッド: Rubyでいうところのクラスメソッド
- インスタンスメソッド: インスタンスメソッドを定義する場所は、インスタンスかプロトタイプかの二種類
  - インスタンスに対して
    - インスタンス作成時にthisが毎回新しく決まる
  - プロトタイプに対して
    - インスタンス作成前からthisの参照先はベースオブジェクトと決まっている

### 関数との違い

- 関数でもクラスのような役割を持つことはできるが、仕様を統一するためにclassが導入された
- classは関数として呼び出すとエラーになる（誤用を防ぐため）

### getter, setter

- getter: クラスのプロパティの値を参照できるようにする
  - 例: getterの値を変数に代入したい時など
- setter: クラスのプロパティに値を代入できるようにする
